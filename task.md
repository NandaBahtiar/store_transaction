# Spring Boot Transaction Management API - Simple CRUD Implementation Prompts

## Project Overview
Create a Spring Boot 3.x backend API for customer transaction management with PostgreSQL database, focusing on CRUD operations without security, JWT, Docker, or Flyway.

---

## Prompt 1: Database Schema & Entity Design

**Task**: Create JPA entities and basic database connection for the transaction management system.

**Requirements**:
- Design entities for: User, Customer, Product, Tax, Transaction, TransactionDetail
- Use basic JPA annotations
- Implement proper relationships (OneToMany, ManyToMany, etc.)
- Add audit fields (created_at, updated_at, created_by, updated_by)
- Configure PostgreSQL connection in application.properties

**Entity Specifications**:
1. **User Entity**: id, username, email, role (ADMIN/STAFF/CUSTOMER), created_at, updated_at
2. **Customer Entity**: id, name, birthdate, birthplace, created_by, created_at, updated_at, updated_by
3. **Product Entity**: id, name, base_price, created_at, updated_at
4. **Tax Entity**: id, name, percentage
5. **ProductTax Entity**: id, product_id, tax_id (join table)
6. **Transaction Entity**: id, customer_id, net_amount, total_amount, total_tax, transaction_time, payment_status, payment_method, staff_id, created_at, updated_at
7. **TransactionDetail Entity**: id, transaction_id, product_id, quantity, unit_price, subtotal, tax_amount

**Database Configuration**:
```properties
spring.datasource.url=jdbc:postgresql://localhost:5432/transaction_db
spring.datasource.username=your_username
spring.datasource.password=your_password
spring.jpa.hibernate.ddl-auto=create-drop
spring.jpa.show-sql=true
```

**Deliverables**:
- JPA Entity classes with @Entity, @Table, @Column annotations
- Basic Repository interfaces extending JpaRepository
- application.properties with PostgreSQL configuration
- Basic schema will be auto-generated by Hibernate

---

## Prompt 2: User Management CRUD APIs

**Task**: Create simple REST controllers and services for user management without authentication.

**Requirements**:
- UserController with basic CRUD operations
- UserService for business logic
- DTO classes for request/response
- Basic input validation
- No security - all endpoints are public

**Endpoints**:
```
POST /api/users (Create new user)
GET /api/users (Get all users)
GET /api/users/{id} (Get user by ID)
PUT /api/users/{id} (Update user)
DELETE /api/users/{id} (Delete user)
```

**User Fields**:
- username (required, unique)
- email (required, unique, valid email format)
- role (ADMIN, STAFF, CUSTOMER)

**Deliverables**:
- UserController class
- UserService class
- UserRepository interface
- UserDTO, UserCreateDTO, UserUpdateDTO classes
- Basic validation using @Valid and validation annotations
- Simple error handling with @ControllerAdvice

---

## Prompt 3: Customer Management CRUD APIs

**Task**: Implement customer management functionality with full CRUD operations.

**Requirements**:
- CustomerController with CRUD operations
- Handle duplicate customers (same name, birthdate, birthplace allowed)
- Audit trail fields
- Search functionality
- Pagination support

**Endpoints**:
```
POST /api/customers (Create new customer)
GET /api/customers (Get all customers with pagination)
GET /api/customers/{id} (Get customer by ID)
PUT /api/customers/{id} (Update customer)
DELETE /api/customers/{id} (Delete customer)
GET /api/customers/search?name=&birthdate=&birthplace= (Search customers)
```

**Customer Fields**:
- name (required)
- birthdate (required, LocalDate format)
- birthplace (required)
- created_by (user ID who created this customer)
- updated_by (user ID who last updated)

**Deliverables**:
- CustomerController, CustomerService, CustomerRepository
- CustomerDTO, CustomerCreateDTO, CustomerUpdateDTO
- Custom repository methods for search
- Pageable support in controller methods

---

## Prompt 4: Product and Tax Management APIs

**Task**: Create product management with tax relationship handling.

**Requirements**:
- Product CRUD operations
- Tax CRUD operations
- Many-to-many relationship between Product and Tax
- Price calculation utilities

**Product Endpoints**:
```
POST /api/products (Create product)
GET /api/products (Get all products)
GET /api/products/{id} (Get product by ID)
PUT /api/products/{id} (Update product)
DELETE /api/products/{id} (Delete product)
POST /api/products/{id}/taxes/{taxId} (Add tax to product)
DELETE /api/products/{id}/taxes/{taxId} (Remove tax from product)
GET /api/products/{id}/taxes (Get all taxes for a product)
```

**Tax Endpoints**:
```
POST /api/taxes (Create tax)
GET /api/taxes (Get all taxes)
GET /api/taxes/{id} (Get tax by ID)
PUT /api/taxes/{id} (Update tax)
DELETE /api/taxes/{id} (Delete tax)
```

**Fields**:
- Product: name (required), base_price (required, BigDecimal)
- Tax: name (required), percentage (required, BigDecimal)

**Deliverables**:
- ProductController, ProductService, ProductRepository
- TaxController, TaxService, TaxRepository
- Product-Tax relationship management
- DTOs for products and taxes
- Price calculation utility methods

---

## Prompt 5: Transaction Management APIs

**Task**: Implement transaction management with automatic calculations.

**Requirements**:
- Transaction CRUD operations
- TransactionDetail handling
- Automatic calculation of amounts and taxes
- Payment status management

**Endpoints**:
```
POST /api/transactions (Create new transaction)
GET /api/transactions (Get all transactions)
GET /api/transactions/{id} (Get transaction by ID)
PUT /api/transactions/{id} (Update transaction)
DELETE /api/transactions/{id} (Delete transaction)
PUT /api/transactions/{id}/status (Update payment status only)
```

**Transaction Creation Process**:
1. Receive transaction with list of products and quantities
2. Validate customer and products exist
3. Calculate line items: quantity Ã— product base_price
4. Calculate tax amounts for each line item
5. Calculate totals: net_amount, total_tax, total_amount
6. Save transaction and transaction details

**Transaction Fields**:
- customer_id (required)
- staff_id (user who creates the transaction)
- payment_status (PAID, NOT_PAID, CANCELLED)
- payment_method (CASH, CARD, TRANSFER)
- transaction_time (auto-generated)
- net_amount, total_amount, total_tax (calculated)

**TransactionDetail Fields**:
- transaction_id, product_id, quantity, unit_price, subtotal, tax_amount

**Deliverables**:
- TransactionController, TransactionService, TransactionRepository
- TransactionDetailService, TransactionDetailRepository
- TransactionDTO, TransactionCreateDTO with nested details
- Calculation utility methods
- Payment status enum

---

## Prompt 6: Transaction Filtering APIs

**Task**: Implement advanced filtering for transactions.

**Requirements**:
- Multiple filter criteria
- Flexible filtering (can use any combination)
- Sorting options
- Pagination

**Filter Endpoint**:
```
GET /api/transactions/filter?
    startDate=2024-01-01&
    endDate=2024-12-31&
    customerName=John&
    paymentStatus=PAID,NOT_PAID&
    paymentMethod=CASH,CARD&
    staffId=123&
    sortBy=transactionTime&
    sortOrder=DESC&
    page=0&
    size=20
```

**Filter Criteria**:
1. Date range (startDate, endDate)
2. Customer name (partial matching, case-insensitive)
3. Payment status (single or multiple values)
4. Payment method (single or multiple values)
5. Staff ID (who created the transaction)
6. Sort by transaction time (ASC/DESC)

**Implementation**:
- Use @Query annotations with JPQL
- Create TransactionFilterDTO for parameters
- Handle optional parameters (null checks)
- Return paginated results

**Deliverables**:
- Enhanced TransactionController with filter endpoint
- TransactionFilterDTO class
- Custom repository methods with @Query
- Parameter validation and null handling

---

## Prompt 7: Reporting APIs

**Task**: Create reporting endpoints for transaction analytics.

**Requirements**:
- Customer spending reports
- Product performance reports
- Simple calculation and aggregation
- Return JSON responses

**Report Endpoints**:
```
GET /api/reports/customer/{customerId}/spending?startDate=&endDate= 
    (Customer spending in date range)
    
GET /api/reports/customer/{customerId}/spending/alltime 
    (Customer total spending all time)
    
GET /api/reports/products/performance 
    (Total revenue per product all time)
    
GET /api/reports/customer/{customerId}/transactions 
    (Customer transaction history)
```

**Report Types**:
1. **Customer Date Range**: Total amount spent between dates
2. **Customer All-Time**: Total amount spent throughout history
3. **Product Performance**: GROUP BY product, SUM(total_amount) from transaction details

**Response Format**:
```json
{
  "customerId": 1,
  "customerName": "John Doe", 
  "totalSpent": 1500000,
  "transactionCount": 25,
  "dateRange": "2024-01-01 to 2024-12-31"
}
```

**Deliverables**:
- ReportController class
- ReportService with calculation methods
- Report DTOs (CustomerSpendingReportDTO, ProductPerformanceReportDTO)
- Custom repository methods with native queries or JPQL
- Proper null handling for date parameters

---

## Prompt 8: Database Initialization & Sample Data

**Task**: Create SQL scripts for database setup and sample data.

**Requirements**:
- Manual SQL schema creation script
- Sample data insertion script
- Realistic test data for all tables
- Script to run in PostgreSQL directly

**Sample Data Requirements**:
- 5 users (1 admin, 2 staff, 2 customers)
- 15 customers with varied data
- 20 products with different prices
- 10 tax types with different percentages
- Product-tax relationships
- 30 transactions with different statuses
- 100+ transaction details

**SQL Files Needed**:
1. **schema.sql** - CREATE TABLE statements
2. **data.sql** - INSERT statements for sample data
3. **setup.sql** - Complete setup script

**Schema Structure**:
```sql
-- Example structure
CREATE TABLE users (
    id BIGSERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    role VARCHAR(20) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
-- ... other tables
```

**Deliverables**:
- schema.sql with all table structures
- data.sql with comprehensive sample data
- README.md with database setup instructions
- Verification queries to check data integrity

---

## Prompt 9: Testing & Postman Collection

**Task**: Create comprehensive testing and API documentation.

**Requirements**:
- Unit tests for service classes
- Integration tests for controllers
- Postman collection for all endpoints
- Test data scenarios

**Test Coverage**:
- CRUD operations for all entities
- Calculation logic (transaction totals, taxes)
- Filtering and searching functionality
- Report generation
- Error handling scenarios

**Postman Collection Structure**:
- Folder for each entity (Users, Customers, Products, etc.)
- Sample requests with test data
- Environment variables for base URL
- Pre-request scripts for data setup where needed

**Test Scenarios**:
- Create transaction with multiple products
- Filter transactions with various criteria
- Generate reports for different customers
- Handle edge cases (empty results, invalid IDs)

**Deliverables**:
- JUnit test classes for services and controllers
- Postman collection (.json file)
- Test data setup in @Before methods
- Integration test configuration
- Testing documentation

---

## Prompt 10: Application Configuration & Deployment Guide

**Task**: Finalize application configuration and create deployment documentation.

**Requirements**:
- Complete application.properties configuration
- Profile-specific configurations
- Error handling improvements
- API documentation
- Deployment instructions

**Configuration Files**:
```properties
# application.properties
server.port=8080
spring.datasource.url=jdbc:postgresql://localhost:5432/transaction_db
spring.datasource.username=postgres
spring.datasource.password=password
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
logging.level.org.springframework.web=DEBUG
```

**Documentation Requirements**:
- API endpoint documentation
- Request/response examples
- Error codes and messages
- Database setup instructions
- How to run the application

**Deliverables**:
- Final application.properties
- Global exception handler improvements
- README.md with complete setup instructions
- API documentation (can be simple markdown)
- Troubleshooting guide

---

## Implementation Order:

1. **Prompt 1** - Database entities and configuration
2. **Prompt 2** - User CRUD APIs (test with Postman)
3. **Prompt 3** - Customer CRUD APIs
4. **Prompt 4** - Product and Tax APIs
5. **Prompt 5** - Transaction management (core feature)
6. **Prompt 6** - Transaction filtering
7. **Prompt 7** - Reporting APIs
8. **Prompt 8** - Database setup scripts
9. **Prompt 9** - Testing and Postman collection
10. **Prompt 10** - Final configuration and documentation

**Testing After Each Prompt**:
- Test endpoints with Postman
- Verify database records
- Check calculations are correct
- Ensure error handling works

This approach focuses on getting a working CRUD API without complex security, containerization, or migration tools.